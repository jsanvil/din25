{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Desarrollo de Interfaces 2025/26","text":""},{"location":"#resultados-de-aprendizaje","title":"Resultados de Aprendizaje","text":"<ul> <li>RA1. Genera interfaces gr\u00e1ficos de usuario mediante editores visuales utilizando las funcionalidades del editor y adaptando el c\u00f3digo generado.</li> <li>RA2. Genera interfaces naturales de usuario utilizando herramientas visuales.</li> <li>RA3. Crea componentes visuales valorando y empleando herramientas espec\u00edficas.</li> <li>RA4. Dise\u00f1a interfaces gr\u00e1ficas identificando y aplicando criterios de usabilidad y accesibilidad.</li> <li>RA5. Crea informes evaluando y utilizando herramientas gr\u00e1ficas.</li> <li>RA6. Documenta aplicaciones seleccionando y utilizando herramientas espec\u00edficas.</li> <li>RA7. Prepara aplicaciones para su distribuci\u00f3n evaluando y utilizando herramientas espec\u00edficas.</li> </ul>"},{"location":"entorno/","title":"\ud83d\udd27 Entorno de trabajo","text":"<p>En este curso utilizaremos las siguientes tecnolog\u00edas:</p> <ul> <li>Repositorios de Git alojados en GitHub para el seguimiento y entrega de las pr\u00e1cticas y proyectos.</li> <li>Visual Studio Code como editor de c\u00f3digo.<ul> <li>Alternativamente se puede utilizar VSCodium que es una versi\u00f3n de c\u00f3digo abierto de VSCode.</li> </ul> </li> <li>Node.js como entorno de ejecuci\u00f3n.<ul> <li>nvm para la gesti\u00f3n de versiones de Node.js en el aula de inform\u00e1tica.</li> </ul> </li> <li>Electron para el desarrollo de aplicaciones de escritorio multiplataforma.</li> <li>Angular para el desarrollo de interfaces gr\u00e1ficas.</li> <li>TypeScript como lenguaje de programaci\u00f3n principal.</li> </ul>"},{"location":"entorno/#visual-studio-code","title":"Visual Studio Code","text":"<p>Para la instalaci\u00f3n de VSCode, descargar el paquete de instalaci\u00f3n que corresponda al sistema operativo de la p\u00e1gina de Visual Studio Code y realizar la instalaci\u00f3n t\u00edpica.</p>"},{"location":"entorno/#version-portable","title":"Versi\u00f3n portable","text":"<p>Si no se dispone de permisos de administrador para instalar software, se puede utilizar la versi\u00f3n portable de VSCode.</p> <p>En la p\u00e1gina oficial de descargas disponemos de empaquetados <code>.zip</code> para MS Windows y <code>.tar.gz</code> para Linux.</p> <p>S\u00f3lo hay que descargar el archivo, descomprimir y ejecutar el archivo <code>code</code>.</p>"},{"location":"entorno/#nodejs-npm-y-nvm","title":"<code>Node.js</code> <code>npm</code> y <code>nvm</code>","text":"<p>npm es el gestor de paquetes de Node.js. Para instalarlo se debe seguir la gu\u00eda en la p\u00e1gina de nodejs.org.</p>"},{"location":"entorno/#instalacion-en-el-perfil-local-de-usuario-para-sistemas-linux","title":"Instalaci\u00f3n en el perfil local de usuario para sistemas Linux","text":"<p>Alternativamente, npm se puede instalar en el perfil local del usuario, para ello utilizaremos nvm que es un gestor de versiones de node que nos permitir\u00e1 utilizar la versi\u00f3n que escojamos nvm-sh</p> <p>Para instalar nvm necesitamos ejecutar el siguiente comando, aunque es recomendable consultar la documentaci\u00f3n de nvm para comprobar que no haya cambiado:</p> <pre><code>curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.40.3/install.sh | bash\n</code></pre> <p>wget</p> <p>Si no se dispone de <code>curl</code>, se puede utilizar <code>wget</code>:</p> <pre><code>wget -qO- https://raw.githubusercontent.com/nvm-sh/nvm/v0.40.3/install.sh | bash\n</code></pre> <p>Cuando termine la instalaci\u00f3n de nvm, tendremos que abrir un nuevo terminal para que reconozca la ruta del ejecutable y proceder a instalar la \u00faltima versi\u00f3n LTS de Node.js de la siguiente forma:</p> <pre><code>nvm install --lts\n</code></pre>"},{"location":"entorno/#git-github-y-github-classroom","title":"Git, GitHub y GitHub Classroom","text":"<ul> <li>Git es un sistema de control de versiones usado com\u00fanmente para c\u00f3digo fuente.</li> <li>GitHub es una plataforma de desarrollo colaborativo que utiliza Git y que nos permitir\u00e1 subir nuestro c\u00f3digo a la nube.</li> <li>GitHub Classroom es una herramienta que nos permitir\u00e1 recibir las tareas y ejercicios de la asignatura.</li> </ul> <p>Por lo tanto ser\u00e1 necesario:</p> <ul> <li> <p>Si no tenemos cuenta en GitHub, Crear una cuenta de GitHub utilizando la cuenta de correo corporativa de la GVA (usuario@alu.edu.gva).</p> <ul> <li>Utiliza el mismo nombre de usuario para la cuenta GitHub.</li> </ul> <p>Ejemplo: Para la cuenta corporativa es <code>jacsanvil@alu.edu.gva</code> el usuario de GitHub debe ser <code>jacsanvil</code></p> </li> <li> <p>Instalar Git</p> <p>Si no est\u00e1s familiarizado en c\u00f3mo funciona git, se recomienda leer la Gu\u00eda de Git. </p> </li> <li> <p>Para tareas sencillas, se recomienda el gestor integrado de Visual Studio Code.</p> </li> <li>Para tareas m\u00e1s complejas, se recomienda utilizar la herramienta de l\u00ednea de comandos de Git o un cliente gr\u00e1fico como GitHub Desktop.</li> </ul>"},{"location":"ud01_intro/","title":"UD1: Introducci\u00f3n","text":"<ul> <li>1.1 - Introducci\u00f3n a Electron</li> <li>1.2 - Primer proyecto con Electron</li> </ul>"},{"location":"ud01_intro/01_electron_intro/","title":"1.1 Introducci\u00f3n a Electron","text":"<ul> <li>Requisitos</li> <li>Conocimientos previos</li> <li>Herramientas necesarias<ul> <li>Editor de c\u00f3digo</li> <li>L\u00ednea de comandos</li> <li>Git y GitHub</li> </ul> </li> <li>Node.js y npm</li> <li>Electron reloader</li> </ul>"},{"location":"ud01_intro/01_electron_intro/#requisitos","title":"Requisitos","text":"<p>Electron es un framework para crear aplicaciones de escritorio usando JavaScript, HTML y CSS. Incorpora Chromium y Node.js en un \u00fanico archivo binario. Permite crear aplicaciones multiplataforma que funcionan en Windows, macOS y Linux con una \u00fanica base com\u00fan de c\u00f3digo JavaScript.</p>"},{"location":"ud01_intro/01_electron_intro/#conocimientos-previos","title":"Conocimientos previos","text":"<p>Electron es una capa de envoltorio nativa para aplicaciones web y se ejecuta en un entorno Node.js. Se asume que el alumnado ha adquirido los conocimientos b\u00e1sicos de desarrollo web vistos en el m\u00f3dulo de primer curso de DAM \"Lenguajes de marcas y sistemas de gesti\u00f3n de informaci\u00f3n\" (LMSGI). Como apoyo se recomendan los siguientes recursos:</p> <ul> <li>Aprende desarrollo web (MDN Web Docs)</li> <li>Introducci\u00f3n a Node.js</li> </ul>"},{"location":"ud01_intro/01_electron_intro/#herramientas-necesarias","title":"Herramientas necesarias","text":""},{"location":"ud01_intro/01_electron_intro/#editor-de-codigo","title":"Editor de c\u00f3digo","text":"<p>Es necesario un editor de texto para escribir el c\u00f3digo, lo m\u00e1s recomendado es el uso de un IDE (Entorno de Desarrollo Integrado). Se recomienda el uso de Visual Studio Code, al ser uno de los m\u00e1s utilizados en el mundo del desarrollo, con ls integraci\u00f3n de m\u00faltiples herramientas que permiten agilizar el trabajo, como el control de versiones git, el terminal integrado de l\u00ednea de comandos o el depurador, entre muchas otras.</p>"},{"location":"ud01_intro/01_electron_intro/#linea-de-comandos","title":"L\u00ednea de comandos","text":"<p>A lo largo del curso se requerir\u00e1 el uso de varias interfaces de l\u00ednea de comandos (CLIs). Se pueden teclear estos comandos v\u00eda terminal:</p> <ul> <li>Windows: Command Prompt, PowerShell, Terminal</li> <li>macOS: Terminal</li> <li>Linux: var\u00eda dependiendo de la distribuci\u00f3n (ej: Terminal GNOME, Konsole)</li> </ul> <p>La mayor\u00eda de los editores de c\u00f3digo tambi\u00e9n vienen con una terminal integrada.</p>"},{"location":"ud01_intro/01_electron_intro/#git-y-github","title":"Git y GitHub","text":"<p>Git es un sistema de control de versiones usado com\u00fanmente para c\u00f3digo fuente, y GitHub es una plataforma de desarrollo colaborativa construida adem\u00e1s de ella. Aunque ninguno de los dos es estrictamente necesario para construir una aplicaci\u00f3n Electron usaremos GitHub para realizar las entregas. Por lo tanto ser\u00e1 necesario:</p> <ul> <li> <p>Crear una cuenta de GitHub utilizando la cuenta de correo corporativa de la GVA (usuario@alu.edu.gva).</p> <ul> <li>Utiliza el mismo nombre de usuario para la cuenta GitHub.</li> </ul> <p>Ejemplo: Para la cuenta corporativa es <code>jacsanvil@alu.edu.gva</code> el usuario de GitHub debe ser <code>jacsanvil</code></p> </li> <li> <p>Instalar Git</p> <p>Si no est\u00e1s familiarizado en como funciona git, se recomienda leer la Gu\u00eda de Git. </p> </li> <li> <p>Se puede utilizar <code>git</code> mediante la terminal o la interfaz gr\u00e1fica de GitHub Desktop.</p> </li> <li>Para tareas sencillas, se recomienda el gestor integrado de Visual Studio Code.</li> </ul>"},{"location":"ud01_intro/01_electron_intro/#nodejs-y-npm","title":"Node.js y npm","text":"<p>Para comenzar a desarrollar una aplicaci\u00f3n Electron es necesario instalar Node.js y el gestor de paquetes npm. Es recomendable utilizar la \u00faltima versi\u00f3n con soporte a largo plazo (LTS).</p> <p>Para comprobar que Node.js se ha instalado correctamente, se puede usar la opci\u00f3n <code>-v</code> cuando en los comandos <code>node</code> y <code>npm</code>. Estos deben imprimir las versiones instaladas.</p> Terminal<pre><code>$ node -v\nv22.19.0\n$ npm -v\n10.9.3\n</code></pre> <p>NOTA</p> <p>Aunque es necesario tener Node.js instalado localmente para desarrollar un proyecto en Electron, el ejecutable final, viene empaquetado con su propio Node.js. Esto significa que los usuarios finales no necesitan instalar Node.js como requisito para ejecutar la aplicaci\u00f3n.</p>"},{"location":"ud01_intro/01_electron_intro/#electron-reloader","title":"Electron reloader","text":"<p>Para que los cambios en el c\u00f3digo se reflejen en la aplicaci\u00f3n, se puede utilizar el paquete electron-reloader que se instala como dependencia de desarrollo.</p> Terminal<pre><code>$ npm install --save-dev electron-reloader\n</code></pre> <p>Despu\u00e9s, en el archivo <code>main.js</code> se a\u00f1ade el siguiente c\u00f3digo:</p> main.js<pre><code>const { app, BrowserWindow } = require('electron')\n\ntry {\n    require('electron-reloader')(module, {\n        debug: true,\n        watchRenderer: true\n    })\n} catch(_) {}\n\n// ...\n</code></pre> <p>Ahora, cuando lancemos la aplicaci\u00f3n con <code>npm start</code> se recargar\u00e1 autom\u00e1ticamente cuando se guarden los cambios en el c\u00f3digo.</p>"},{"location":"ud01_intro/021_actividad/","title":"1.2.1 Actividad: Prepar el entorno y crear la primera aplicaci\u00f3n en Electron","text":"<p>Para realizar la actividad se debe seguir los siguientes pasos:</p> <ol> <li> <p>Acepta la invitaci\u00f3n a la actividad en GitHub Classroom: https://classroom.github.com/a/FU7tJcIi</p> <ul> <li>Selecciona tu correo corporativo del listado.</li> <li>Acepta la actividad.</li> </ul> <p>Warning</p> <p>Debes utilizar tu cuenta corporativa de la GVA</p> <p>Con esto lo que se consigue es crear un repositorio remoto donde se subir\u00e1 el c\u00f3digo de la actividad.</p> </li> <li> <p>Copia la URL del repositorio creado.</p> Ejemplo de URL del repositorio<pre><code>https://github.com/DAM-DIN-25/act1-electron-intro-jsanvil\n</code></pre> </li> <li> <p>Clona el repositorio en tu m\u00e1quina local</p> <p>Puedes utilizar VS Code para clonar el repositorio o la terminal con el comando:</p> Clonar el repositorio<pre><code>git clone &lt;url-repositorio&gt;\n</code></pre> </li> <li> <p>Sigue los pasos del punto 1.2 Creando la primera aplicaci\u00f3n en Electron para configurar el entorno de desarrollo y crear un proyecto Electron.</p> <p>\ud83d\udea8\ud83d\udea8\ud83d\udea8 .gitignore \ud83d\udea8\ud83d\udea8\ud83d\udea8</p> <p>No olvides a\u00f1adir el archivo <code>.gitignore</code> en la ra\u00edz del proyecto para que no se suban los archivos innecesarios al repositorio.</p> <p>Ejemplo de archivo <code>.gitignore</code></p> </li> <li> <p>Realiza los cambios necesarios en el c\u00f3digo para que la aplicaci\u00f3n muestre un mensaje de bienvenida personalizado.</p> </li> <li> <p>Realiza un commit con los cambios realizados y sube el c\u00f3digo al repositorio remoto.</p> Terminal<pre><code>git add .\ngit commit -m \"Actividad finalizada\"\ngit push\n</code></pre> <p>Warning</p> <p>Es posible que solicite configuraci\u00f3n extra antes de hacer el primer commit</p> Terminal<pre><code>git config --global user.name \"Nombre Apellido\"\ngit config --global user.email \"user@alu.edu.gva.es\"\n</code></pre> </li> <li> <p>Comprueba que los cambios se han subido correctamente al repositorio remoto.</p> </li> </ol>"},{"location":"ud01_intro/02_electron_firstapp/","title":"1.2 Creando la primera aplicaci\u00f3n en Electron","text":"<ul> <li>Objetivos</li> <li>Iniciando el proyecto con <code>npm</code></li> <li>\ud83d\udea8 Agregando <code>.gitignore</code> \ud83d\udea8</li> <li>Ejecutar una aplicaci\u00f3n Electron</li> <li>Cargar una html en un <code>BrowserWindow</code></li> <li>Importando m\u00f3dulos</li> <li>Escribir una funci\u00f3n reutilizable para instanciar ventanas</li> <li>Llamar a su funci\u00f3n cuando la aplicaci\u00f3n est\u00e9 lista</li> <li>Administrar el ciclo de vida de la ventana de la aplicaci\u00f3n</li> <li>Salir de la aplicaci\u00f3n cuando todas las ventanas est\u00e9n cerradas (Windows y Linux)</li> <li>Abrir una ventana si no hay ninguna abierta (macOS)</li> <li>C\u00f3digo final</li> <li>Depurando en VS Code</li> <li>Resumen</li> <li>Referencia</li> </ul>"},{"location":"ud01_intro/02_electron_firstapp/#objetivos","title":"Objetivos","text":"<p>En esta parte se ense\u00f1ar\u00e1 a configurar un proyecto Electron y escribir una aplicaci\u00f3n inicial sencilla. Al final de esta secci\u00f3n, se podr\u00e1 ejecutar una aplicaci\u00f3n Electron en modo de desarrollo desde el terminal.</p>"},{"location":"ud01_intro/02_electron_firstapp/#iniciando-el-proyecto-con-npm","title":"Iniciando el proyecto con <code>npm</code>","text":"<p>Las aplicaciones Electron se organizan usando npm, con el archivo <code>package.json</code> como punto de entrada. Comienza creando una carpeta e inicializando un paquete npm dentro de ella con el comando <code>npm init</code>.</p> Terminal<pre><code>mkdir my-electron-app\ncd my-electron-app\nnpm init\n</code></pre> <p>Este comando pedir\u00e1 que configures algunos atributos del <code>package.json</code>. Hay algunas reglas que seguir en esta gu\u00eda:</p> <ul> <li>El punto de entrada de la aplicaci\u00f3n debe ser el archivo <code>main.js</code>.</li> <li>\"author\", \"license\" y \"description\" pueden tener cualquier valor, pero ser\u00e1n necesarios para el empaquetado m\u00e1s adelante.</li> <li>Se puede aceptar la configuraci\u00f3n por defecto, normalmente indicada entre par\u00e9ntesis, pulsando la tecla <code>intro</code>.</li> </ul> Ejemplo del proceso de configuraci\u00f3n de `package.json` con `npm init`<pre><code>This utility will walk you through creating a package.json file.\nIt only covers the most common items, and tries to guess sensible defaults.\n\nSee `npm help init` for definitive documentation on these fields\nand exactly what they do.\n\nUse `npm install &lt;pkg&gt;` afterwards to install a package and\nsave it as a dependency in the package.json file.\n\nPress ^C at any time to quit.\npackage name: (my-electron-app) \nversion: (1.0.0) \ndescription: \nentry point: (index.js) main.js\ntest command: \ngit repository: \nkeywords: \nauthor: \nlicense: (ISC) \nAbout to write to /home/jacinto/Documentos/Curso2025/din/my-electron-app/package.json:\n\n{\n  \"name\": \"my-electron-app\",\n  \"version\": \"1.0.0\",\n  \"description\": \"\",\n  \"main\": \"main.js\",\n  \"scripts\": {\n    \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\"\n  },\n  \"author\": \"\",\n  \"license\": \"ISC\"\n}\n\n\nIs this OK? (yes) \n</code></pre> <p>Ahora, instala Electron en las <code>devDependencies</code> de la aplicaci\u00f3n, que es la lista de dependencias de paquetes externos de desarrollo exclusivo que no se requieren en producci\u00f3n.</p> Terminal<pre><code>npm install electron --save-dev\n</code></pre> <p>\u00bfPor qu\u00e9 Electron es una dependencia?</p> <p>Esto puede parecer poco intuitivo ya que el c\u00f3digo de producci\u00f3n ejecuta API de Electron. Sin embargo, las aplicaciones finales incluir\u00e1n el binario de Electron, eliminando la necesidad de especificarlo como una dependencia de la aplicaci\u00f3n binaria final a distribuir en producci\u00f3n.</p> <p>El archivo <code>package.json</code> deber\u00eda verse as\u00ed despu\u00e9s de inicializar su paquete e instalar Electron. </p> package.json<pre><code>{\n  \"name\": \"my-electron-app\",\n  \"version\": \"1.0.0\",\n  \"description\": \"\",\n  \"main\": \"main.js\",\n  \"scripts\": {\n    \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\"\n  },\n  \"author\": \"\",\n  \"license\": \"ISC\",\n  \"devDependencies\": {\n    \"electron\": \"^38.1.0\"\n  }\n}\n</code></pre> <p>Tambi\u00e9n debe aparecer la carpeta <code>node_modules/</code> que contiene el ejecutable de Electron, as\u00ed como un archivo de bloqueo <code>package-lock.json</code> que especifica las versiones de dependencia exactas que se instalar\u00e1n.</p> <p>Instrucciones de instalaci\u00f3n avanzadas</p> <p>Si la instalaci\u00f3n de Electron falla, se puede consultar la documentaci\u00f3n de Instalaci\u00f3n avanzada para obtener instrucciones sobre c\u00f3mo descargar mirrors, servidores proxy y soluci\u00f3n de problemas.</p>"},{"location":"ud01_intro/02_electron_firstapp/#agregando-gitignore","title":"\ud83d\udea8 Agregando <code>.gitignore</code> \ud83d\udea8","text":"<p>El archivo <code>.gitignore</code> especifica qu\u00e9 archivos y directorios evitar en el seguimiento con Git. Se debe colocar una copia de la plantilla GitHub's Node.js gitignore template en la carpeta ra\u00edz de tu proyecto para evitar el seguimiento la carpeta <code>node_modules/</code> del proyecto.</p> <p>ADVERTENCIA</p> <p>No se debe subir la carpeta <code>node_modules/</code> al repositorio remoto, ya que puede ser muy grande y no es necesario. Las dependencias se pueden reinstalar en cualquier momento utilizando el archivo <code>package.json</code> y el comando <code>npm install</code>.</p> <p>Todos los a\u00f1os muchos alumnos omiten este paso y terminan subiendo la carpeta <code>node_modules/</code> a su repositorio, provocando que muchas veces el repositorio supere el l\u00edmite de tama\u00f1o permitido por GitHub y no puedan entregar sus pr\u00e1cticas.</p>"},{"location":"ud01_intro/02_electron_firstapp/#ejecutar-una-aplicacion-electron","title":"Ejecutar una aplicaci\u00f3n Electron","text":"<p>El script <code>main</code> que definiste en <code>package.json</code> es el punto de inicio de cualquier aplicaci\u00f3n. Este script controla el proceso principal, que se ejecuta en un entorno Node.js y es responsable de controlar el ciclo de vida de su aplicaci\u00f3n, mostrar interfaces nativas, realizar operaciones con privilegios y administrar los procesos de renderizado.</p> <p>Antes de crear la primera aplicaci\u00f3n, primero utilizar\u00e1 un script para asegurar de que el punto de entrada del proceso principal est\u00e1 configurado correctamente. Crea un archivo <code>main.js</code> en la carpeta ra\u00edz del proyecto con una sola l\u00ednea de c\u00f3digo:</p> main.js<pre><code>console.log('Hola desde Electron \ud83d\udc4b')\n</code></pre> <p>Debido a que el proceso principal es un int\u00e9rprete de Node.js, se puede ejecutar c\u00f3digo con el comando <code>electron</code>. Para ejecutar este script, agrega <code>\"electron .\"</code> al comando de inicio (<code>\"start\"</code>) en el atributo <code>\"scripts\"</code> del archivo <code>paquete.json</code>. Este comando le indicar\u00e1 al ejecutable que busque el script principal en el directorio actual y lo ejecute en modo de desarrollo.</p> package.json<pre><code>{\n  \"name\": \"my-electron-app\",\n  \"version\": \"1.0.0\",\n  \"description\": \"\",\n  \"main\": \"main.js\",\n  \"scripts\": {\n    \"start\": \"electron .\",\n    \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\"\n  },\n  \"author\": \"\",\n  \"license\": \"ISC\",\n  \"devDependencies\": {\n    \"electron\": \"^38.1.0\"\n  }\n}\n</code></pre> Terminal<pre><code>npm run start\n</code></pre> <p>El terminal deber\u00eda mostrar \"Hola desde Electron \ud83d\udc4b.\" \u00a1Enhorabuena, has ejecutado tu primera l\u00ednea de c\u00f3digo en Electron! A continuaci\u00f3n, veremos como crear interfaces de usuario en HTML y cargarlas en una ventana nativa.</p>"},{"location":"ud01_intro/02_electron_firstapp/#cargar-una-html-en-un-browserwindow","title":"Cargar una html en un <code>BrowserWindow</code>","text":"<p>Cada ventana muestra una p\u00e1gina web que se puede cargar desde un archivo HTML local o desde una direcci\u00f3n web remota. Para este ejemplo, se cargar\u00e1 desde un archivo local. Comienza creando una p\u00e1gina web b\u00e1sica en un archivo <code>index.html</code> en la carpeta ra\u00edz del proyecto:</p> index.html<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;meta charset=\"UTF-8\" /&gt;\n    &lt;meta\n      http-equiv=\"Content-Security-Policy\"\n      content=\"default-src 'self'; script-src 'self'\"\n    /&gt;\n    &lt;meta\n      http-equiv=\"X-Content-Security-Policy\"\n      content=\"default-src 'self'; script-src 'self'\"\n    /&gt;\n    &lt;title&gt;Hello from Electron renderer!&lt;/title&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;h1&gt;Hello from Electron renderer!&lt;/h1&gt;\n    &lt;p&gt;\ud83d\udc4b&lt;/p&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p>Ahora que tenemos una p\u00e1gina web, se puede cargar en una ventana del navegador Electron. Reemplaza el contenido del archivo <code>main.js</code> con el siguiente c\u00f3digo. Se explicar\u00e1 cada bloque resaltado por separado.</p> main.js<pre><code>const { app, BrowserWindow } = require('electron')\n\nconst createWindow = () =&gt; {\n  const win = new BrowserWindow({\n    width: 800,\n    height: 600\n  })\n\n  win.loadFile('index.html')\n}\n\napp.whenReady().then(() =&gt; {\n  createWindow()\n})\n</code></pre>"},{"location":"ud01_intro/02_electron_firstapp/#importando-modulos","title":"Importando m\u00f3dulos","text":"main.js (l\u00ednea 1)<pre><code>const { app, BrowserWindow } = require('electron')\n\n...\n</code></pre> <p>En la primera l\u00ednea, estamos importando dos m\u00f3dulos Electron con la sintaxis del m\u00f3dulo CommonJS:</p> <ul> <li><code>app</code>, controla el ciclo de vida del evento de su aplicaci\u00f3n.</li> <li><code>BrowserWindow</code>, que crea y administra ventanas de aplicaciones.</li> </ul> <p>Convenciones de capitalizaci\u00f3n de nombres</p> <p>Es posible que hayas notado la diferencia de may\u00fasculas entre app y los m\u00f3dulos de BrowserWindow. Electron sigue las convenciones t\u00edpicas de JavaScript, donde los m\u00f3dulos se indican en PascalCase y son constructores de clases instanciables (por ejemplo, <code>BrowserWindow</code>, <code>Tray</code>, <code>Notification</code>) mientras que los m\u00f3dulos camelCase no son instanciables (por ejemplo, <code>app</code>, <code>ipcRenderer</code>, <code>webContents</code>).</p>"},{"location":"ud01_intro/02_electron_firstapp/#escribir-una-funcion-reutilizable-para-instanciar-ventanas","title":"Escribir una funci\u00f3n reutilizable para instanciar ventanas","text":"<p>La funci\u00f3n <code>createWindow()</code> carga la p\u00e1gina web en una nueva instancia de <code>BrowserWindow</code>:</p> main.js (l\u00edneas 3-10)<pre><code>...\nconst createWindow = () =&gt; {\n  const win = new BrowserWindow({\n    width: 800,\n    height: 600\n  })\n\n  win.loadFile('index.html')\n}\n...\n</code></pre>"},{"location":"ud01_intro/02_electron_firstapp/#llamar-a-su-funcion-cuando-la-aplicacion-este-lista","title":"Llamar a su funci\u00f3n cuando la aplicaci\u00f3n est\u00e9 lista","text":"main.js (l\u00edneas 12-14)<pre><code>...\napp.whenReady().then(() =&gt; {\n  createWindow()\n})\n</code></pre> <p>Muchos de los m\u00f3dulos principales de son emisores de eventos de Node.js que se adhieren a la arquitectura asincr\u00f3nica basada en eventos de Node. El m\u00f3dulo de aplicaci\u00f3n es uno de estos emisores.</p> <p><code>BrowserWindows</code> solo se puede crear despu\u00e9s de que se del evento <code>ready</code> del m\u00f3dulo de la aplicaci\u00f3n. Puede esperar este evento utilizando la API <code>app.whenReady()</code> y llamando a <code>createWindow()</code> una vez que se cumpla su promesa.</p> <p>evento <code>ready</code></p> <p>Normalmente los eventos de Node.js se escuchan utilizando la funci\u00f3n <code>.on</code> de un emisor.</p> <pre><code>app.on('ready', () =&gt; {\n// app.whenReady().then(() =&gt; {\ncreateWindow()\n})\n</code></pre> <p>Sin embargo, Electron expone <code>app.whenReady()</code> para evitar problemas al escuchar directamente el evento <code>ready</code>.</p> <p>En este momento, al ejecutar el comando de <code>start</code> de la aplicaci\u00f3n deber\u00eda abrir con una ventana que muestre la p\u00e1gina web.</p> <p>Cada p\u00e1gina web que la aplicaci\u00f3n muestra en una ventana se ejecutar\u00e1 en un proceso separado llamado renderer process (proceso de renderizado) (o simplemente renderer para abreviar). Los procesos de renderizado tienen acceso a las mismas API de JavaScript y herramientas que se utilizan para el desarrollo web front-end t\u00edpico, como el uso de webpack para agrupar y minimizar su c\u00f3digo o React para crear interfaces de usuario.</p>"},{"location":"ud01_intro/02_electron_firstapp/#administrar-el-ciclo-de-vida-de-la-ventana-de-la-aplicacion","title":"Administrar el ciclo de vida de la ventana de la aplicaci\u00f3n","text":"<p>Las ventanas de las aplicaciones se comportan de manera diferente en cada sistema operativo. En lugar de hacer cumplir estas convenciones de forma predeterminada, Electron ofrece la opci\u00f3n de implementarlas en el c\u00f3digo de su aplicaci\u00f3n si desea seguirlas. Puede implementar convenciones b\u00e1sicas de ventana escuchando los eventos emitidos por la aplicaci\u00f3n y los m\u00f3dulos de <code>BrowserWindow</code>.</p> <p>Flujo de control espec\u00edfico</p> <p>La verificaci\u00f3n con la variable <code>process.platform</code> de Node puede ayudar a ejecutar c\u00f3digo de manera condicional en ciertas plataformas. Se debe tener en cuenta que s\u00f3lo hay tres plataformas posibles en las que Electron puede ejecutarse: <code>win32</code> (Windows), <code>linux</code> (Linux) y <code>darwin</code> (macOS).</p>"},{"location":"ud01_intro/02_electron_firstapp/#salir-de-la-aplicacion-cuando-todas-las-ventanas-esten-cerradas-windows-y-linux","title":"Salir de la aplicaci\u00f3n cuando todas las ventanas est\u00e9n cerradas (Windows y Linux)","text":"<p>En Windows y Linux, cerrar todas las ventanas generalmente cerrar\u00e1 una aplicaci\u00f3n por completo. Para implementar este patr\u00f3n en Electron, se debe escuchar el evento <code>window-all-closed</code> del m\u00f3dulo de la aplicaci\u00f3n y llama a <code>app.quit()</code> para salir de la aplicaci\u00f3n si el usuario no est\u00e1 en macOS.</p> <pre><code>app.on('window-all-closed', () =&gt; {\n  if (process.platform !== 'darwin') app.quit()\n})\n</code></pre>"},{"location":"ud01_intro/02_electron_firstapp/#abrir-una-ventana-si-no-hay-ninguna-abierta-macos","title":"Abrir una ventana si no hay ninguna abierta (macOS)","text":"<p>Por el contrario, el comportamiento por defecto de las aplicaciones de macOS es que generalmente contin\u00faan ejecut\u00e1ndose incluso sin ninguna ventana abierta. Activar la aplicaci\u00f3n cuando no hay ventanas disponibles deber\u00eda abrir una nueva.</p> <p>Para implementar esta caracter\u00edstica, escuchar el evento <code>activate</code> del m\u00f3dulo de la aplicaci\u00f3n y llamar a su m\u00e9todo <code>createWindow()</code> existente si no hay ning\u00fan <code>BrowserWindows</code> abierto.</p> <p>Debido a que las ventanas no se pueden crear antes del evento <code>ready</code>, solo deber\u00eda escuchar el evento <code>activate</code> despu\u00e9s de inicializar la aplicaci\u00f3n. Haz esto escuchando solo los eventos de activaci\u00f3n dentro del <code>callback</code> de <code>whenReady()</code>.</p> <pre><code>app.whenReady().then(() =&gt; {\n  createWindow()\n\n  app.on('activate', () =&gt; {\n    if (BrowserWindow.getAllWindows().length === 0) createWindow()\n  })\n})\n</code></pre>"},{"location":"ud01_intro/02_electron_firstapp/#codigo-final","title":"C\u00f3digo final","text":"main.js<pre><code>const { app, BrowserWindow } = require('electron')\n\nconst createWindow = () =&gt; {\n  const win = new BrowserWindow({\n    width: 800,\n    height: 600\n  })\n\n  win.loadFile('index.html')\n}\n\napp.whenReady().then(() =&gt; {\n  createWindow()\n\n  app.on('activate', () =&gt; {\n    if (BrowserWindow.getAllWindows().length === 0) {\n      createWindow()\n    }\n  })\n})\n\napp.on('window-all-closed', () =&gt; {\n  if (process.platform !== 'darwin') {\n    app.quit()\n  }\n})\n</code></pre> index.html<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;meta charset=\"UTF-8\" /&gt;\n    &lt;meta\n      http-equiv=\"Content-Security-Policy\"\n      content=\"default-src 'self'; script-src 'self'\" /&gt;\n    &lt;meta\n      http-equiv=\"X-Content-Security-Policy\"\n      content=\"default-src 'self'; script-src 'self'\" /&gt;\n    &lt;title&gt;Hola desde Electron renderer!&lt;/title&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;h1&gt;Hola desde Electron renderer!&lt;/h1&gt;\n    &lt;p&gt;\ud83d\udc4b&lt;/p&gt;\n    &lt;p id=\"info\"&gt;&lt;/p&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre>"},{"location":"ud01_intro/02_electron_firstapp/#depurando-en-vs-code","title":"Depurando en VS Code","text":"<p>Para depurar la aplicaci\u00f3n usando VS Code, se debe adjuntar VS code para ambos procesos tanto el principal y los renderizadores. Aqu\u00ed un ejemplo de configuraci\u00f3n. Crea un nuevo archivo <code>launch.json</code> en el directorio <code>.vscode\\</code> del proyecto:</p> .vscode/launch.json<pre><code>{\n  \"version\": \"0.2.0\",\n  \"compounds\": [\n    {\n      \"name\": \"Main + renderer\",\n      \"configurations\": [\"Main\", \"Renderer\"],\n      \"stopAll\": true\n    }\n  ],\n  \"configurations\": [\n    {\n      \"name\": \"Renderer\",\n      \"port\": 9222,\n      \"request\": \"attach\",\n      \"type\": \"chrome\",\n      \"webRoot\": \"${workspaceFolder}\"\n    },\n    {\n      \"name\": \"Main\",\n      \"type\": \"node\",\n      \"request\": \"launch\",\n      \"cwd\": \"${workspaceFolder}\",\n      \"runtimeExecutable\": \"${workspaceFolder}/node_modules/.bin/electron\",\n      \"windows\": {\n        \"runtimeExecutable\": \"${workspaceFolder}/node_modules/.bin/electron.cmd\"\n      },\n      \"args\": [\".\", \"--remote-debugging-port=9222\"],\n      \"outputCapture\": \"std\",\n      \"console\": \"integratedTerminal\"\n    }\n  ]\n}\n</code></pre> <p>La opci\u00f3n \"Main + renderer\" aparecer\u00e1 cuando selecciones \"Run and debug\" en la barra lateral, lo que le permitir\u00e1 establecer puntos de interrupci\u00f3n e inspeccionar todas las variables, entre otras cosas, tanto en el proceso principal como en el renderizador.</p> <p>Lo que hemos hecho en el archivo <code>launch.json</code> es crear 3 configuraciones:</p> <ul> <li><code>Main</code> se utiliza para iniciar el proceso principal y tambi\u00e9n exponer el puerto 9222 para la depuraci\u00f3n remota (<code>--remote-debugging-port=9222</code>). Este es el puerto que usaremos para adjuntar el depurador del <code>Renderer</code>. Debido a que el proceso principal es un proceso de Node.js, el tipo se establece en <code>node</code>.</li> <li><code>Renderer</code> se utiliza para depurar el proceso de renderizado. Debido a que el proceso principal es el que crea el proceso, tenemos que adjuntarlo (<code>\"request\": \"attach\"</code>) en lugar de crear uno nuevo. El proceso de renderizado es web, por lo que el depurador que debemos usar es <code>chrome</code>.</li> <li><code>Main + renderer</code> es una tarea compuesta que ejecuta las anteriores simult\u00e1neamente.</li> </ul> <p>ADVERTENCIA</p> <p>Debido a que estamos adjuntando un proceso en <code>Renderer</code>, es posible que las primeras l\u00edneas de su c\u00f3digo se omitan ya que el depurador no habr\u00e1 tenido tiempo suficiente para conectarse antes de que se ejecuten. Puede solucionar este problema actualizando la p\u00e1gina o estableciendo un tiempo de espera antes de ejecutar el c\u00f3digo en modo de desarrollo.</p>"},{"location":"ud01_intro/02_electron_firstapp/#resumen","title":"Resumen","text":"<p>Las aplicaciones Electron se configuran mediante paquetes npm. El ejecutable debe instalarse en las <code>devDependencies</code> de su proyecto y puede ejecutarse en modo de desarrollo usando un script en el archivo <code>package.json</code>.</p> <p>El ejecutable toma el punto de entrada de JavaScript que se encuentra en la propiedad <code>main</code> de <code>paquete.json</code>. Este archivo controla el proceso principal, que ejecuta una instancia de Node.js y es responsable del ciclo de vida de su aplicaci\u00f3n, mostrando interfaces nativas, realizando operaciones privilegiadas y administrando procesos de renderizado.</p> <p>Los procesos de renderizado (o renderers) son responsables de mostrar contenido gr\u00e1fico. Puedes cargar una p\u00e1gina web en un renderer apunt\u00e1ndola a una direcci\u00f3n web o a un archivo HTML local. Los renderers se comportan de manera muy similar a las p\u00e1ginas web normales y tienen acceso a las mismas API web.</p>"},{"location":"ud01_intro/02_electron_firstapp/#referencia","title":"Referencia","text":"<ul> <li>Electron: Building your First App</li> </ul>"}]}